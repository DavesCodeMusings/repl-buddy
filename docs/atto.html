<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>atto API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atto</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># atto
#   (combining form) a metric system unit prefix denoting 10 to the -18 power
#   (noun) a tiny line-based text editor modeled as a subset of the ed editor

from sys import stdout, exit
from text_buffer import TextBuffer

class Atto(TextBuffer):
    &#34;&#34;&#34;
    A primitive line editor, painfully similar to the ed editor, but
    with without the cool regex stuff.
    &#34;&#34;&#34;
    cmd_prompt = &#39;*&#39;
    text_prompt = &#39;&gt;&#39;

    def help(self, **kwargs):
        &#34;&#34;&#34;
        Display brief usage summary
        &#34;&#34;&#34;
        help_text = &#39;\n&#39;.join([
            &#39;Usage: {addr}cmd&#39;,
            &#39;&#39;,
            &#39;Line Addressing&#39;,
            &#39;------------------------------&#39;,
            &#39;{n}         single line&#39;,
            &#39;{n1},{n2}   range of lines&#39;,
            &#39;.           current line&#39;,
            &#39;$           last line&#39;,
            &#39;%           all lines 1,$&#39;,
            &#39;/regexp/    next matching line&#39;,
            &#39;&#39;,
            &#39;Command Summary&#39;,
            &#39;---------------------------------------&#39;,
            &#39;{n}a        Append new line(s) after&#39;,
            &#39;{n1},{n2}c  Change (replace) line(s)&#39;,
            &#39;{n1},{n2}d  Delete line(s)&#39;,
            &#39;e [path]    Edit new file&#39;,
            &#39;f [path]    View/change filename&#39;,
            &#39;{n}i        Insert new line(s) before&#39;,
            &#39;{n1},{n2}n  Print with numbered lines&#39;,
            &#39;{n1},{n2}p  Print&#39;,
            &#39;q           Quit&#39;,
            &#39;w [path]    Write (save) buffer to file&#39;
        ])
        stdout.write(help_text + &#39;\n&#39;)

    def _input_multiline(self):
        &#34;&#34;&#34;
        Yield user input as lines until a single . is encountered.
        Used by insert and append operations.
        &#34;&#34;&#34;
        stdout.write(&#39;Enter a single . to exit input mode.\n&#39;)
        while True:
            text = input(self.text_prompt)
            if text != &#39;.&#39;:
                yield text
            else:
                return

    def _prompt_filename(self, prompt=&#39;Filename&#39;):
        &#34;&#34;&#34;
        Ask for a filename offering the current one as a default value.
        &#34;&#34;&#34;
        if self.filename != None:
            filename = input(&#39;{:s} [{:s}]: &#39;.format(prompt, self.filename))
        else:
            filename = input(&#39;{:s}: &#39;.format(prompt))
        return filename

    def _is_valid_addr(self, start=None, stop=None, dest=None, zero_start_ok=False):
        &#34;&#34;&#34;
        Test if address parameters in range, non-overlapping, etc.
        &#34;&#34;&#34;
        valid_start = 0 if (zero_start_ok == True) else 1

        if start == None:
            return False
        if start &lt; valid_start or start &gt; len(self._buffer):
            return False

        if stop != None:
            if stop &lt; 1 or stop &gt; len(self._buffer):
                return False
            if stop &lt; start:
                return False

        if dest != None:
            if dest &lt; 0 or dest &gt; len(self._buffer):
                return False
            if dest &gt;= start and dest &lt;= stop:
                return False

        return True

    def append(self, **kwargs):
        &#34;&#34;&#34;
        Add new lines after the indicated line number.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        if self._is_valid_addr(start, zero_start_ok=True) == False:
            return False

        line_num = start
        for line in self._input_multiline():
            line_num += 1
            self.insert_line(line_num, line)
        self._current_line = line_num

    def change(self, **kwargs):
        &#34;&#34;&#34;
        Replace line(s) with new line(s).
        &#34;&#34;&#34;
        self.delete(**kwargs)
        self.insert(**kwargs)

    def delete(self, **kwargs):
        &#34;&#34;&#34;
        Remove a range of lines from the buffer.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or start
        if self._is_valid_addr(start, stop) == False:
            return False
        self.delete_range(start, stop)
        self._current_line = start

    def edit(self, **kwargs):
        &#34;&#34;&#34;
        Load a new file into the buffer.
        &#34;&#34;&#34;
        if self._is_dirty == True:
            stdout.write(&#39;Unsaved changes exist. Use uppercase E to override.\n&#39;)
        else:
            filename = kwargs.get(&#39;param&#39;) or self.filename or self._prompt_filename()
            if filename != None:
                self.purge()
                self.load(filename)
                self._is_dirty = False
                self._current_line = len(self._buffer)
                self.filename = filename

    def edit_unconditional(self, **kwargs):
        &#34;&#34;&#34;
        Load a new file into the buffer, disregarding unsaved changes.
        &#34;&#34;&#34;
        self._is_dirty = False
        self.edit(**kwargs)

    def file(self, **kwargs):
        &#34;&#34;&#34;
        Show current filename or replace if param is present
        &#34;&#34;&#34;
        new_name = kwargs.get(&#39;param&#39;)
        if new_name != &#39;&#39;:
            self.filename = new_name
        else:
            stdout.write((self.filename or &#39;(none)&#39;) + &#39;\n&#39;)

    def insert(self, **kwargs):
        &#34;&#34;&#34;
        Add new lines after the indicated line number.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        if self._is_valid_addr(start) == False:
            return False

        line_num = start
        for line in self._input_multiline():
            self.insert_line(line_num, line)
            line_num += 1
        self._current_line = line_num - 1

    def join(self, **kwargs):
        &#34;&#34;&#34;
        Combine lines.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or self._current_line
        if self._is_valid_addr(start, stop) == False:
            return False

        self._buffer[start-1:stop] = [&#39;&#39;.join(self._buffer[start-1:stop])]
        self._current_line = start
        self._is_dirty = True

    def move(self, **kwargs):
        &#34;&#34;&#34;
        Like transfer but remove the source range after the copy.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;)
        stop = kwargs.get(&#39;stop&#39;) or start
        dest = kwargs.get(&#39;param&#39;)
        if self._is_valid_addr(start, stop) == False:
            return False
        self.copy_range(start, stop, dest)
        offset = stop - start + 1 if (dest &lt; start) else 0
        self.delete_range(start+offset, stop+offset)
        self._current_line = dest - 1 + stop - start

    def number(self, **kwargs):
        &#34;&#34;&#34;
        Print lines prefixed with line numbers.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or start
        if self._is_valid_addr(start, stop) == False:
            return False

        if stop &lt; 10:
            line_num_field = &#39;{:&gt;1d}&#39;
        elif stop &lt; 100:
            line_num_field = &#39;{:&gt;2d}&#39;
        elif stop &lt; 1000:
            line_num_field = &#39;{:&gt;3d}&#39;
        else:
            line_num_field = &#39;{:&gt;4d}&#39;

        line_num = start
        while line_num &lt;= stop:
            stdout.write(line_num_field.format(line_num) + &#39; &#39;)
            stdout.write(self.get_line(line_num) + &#39;\n&#39;)
            line_num += 1
        self._current_line = stop

    def print(self, **kwargs):
        &#34;&#34;&#34;
        Display a range of buffer lines, possibly truncated to fit.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or start
        line_length = kwargs.get(&#39;line_length&#39;)
        if self._is_valid_addr(start, stop) == False:
            return False

        line_num = start
        while line_num &lt;= stop:
            if line_length == None:
                stdout.write(self.get_line(line_num) + &#39;\n&#39;)
            else:
                stdout.write(self.get_line(line_num)[:line_length] + &#39;\n&#39;)
            line_num += 1
        self._current_line = stop

    def quit(self, **kwargs):
        if self._is_dirty == False or kwargs.get(&#39;param&#39;) == &#39;!&#39;:
            self.quit_unconditional()
        else:
            stdout.write(&#39;Unsaved changes exist. Use uppercase Q to override.\n&#39;)

    def quit_unconditional(self, **kwargs):
        del self._buffer
        exit(0)

    def show_line_number(self, **kwargs):
        line_num = kwargs.get(&#39;start&#39;) or self._current_line
        stdout.write(str(line_num) + &#39;\n&#39;)

    def toggle_verbosity(self, **kwargs):
        self.verbose = not self.verbose
        state = &#39;on&#39; if self.verbose else &#39;off&#39;
        stdout.write(&#39;Verbose messages: {}\n&#39;.format(state))

    def transfer(self, **kwargs):
        &#34;&#34;&#34;
        Copy lines start..stop to the line after dest.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;)
        stop = kwargs.get(&#39;stop&#39;) or start
        dest = kwargs.get(&#39;param&#39;)
        if self._is_valid_addr(start, stop) == False:
            return False
        self.copy_range(start, stop, dest)
        self._current_line = dest + stop - start + 1

    def write(self, **kwargs):
        &#34;&#34;&#34;
        Save the buffer to a file.
        &#34;&#34;&#34;
        filename = kwargs.get(&#39;param&#39;) or self.filename or self._prompt_filename()
        if (filename):
            result = self.save(filename)
            if (result == False):
                stdout.write(&#39;Write failed!\n&#39;)

    def parse(self, cmd_string):
        &#34;&#34;&#34;
        Split a command string into address range, command, and parameter.
        &#34;&#34;&#34;
        if (cmd_string == None or cmd_string == &#39;&#39;):
            return None, None, None, None

        # RegEx address format can be &#39;/expr&#39; or &#39;/expr/&#39;
        # &#39;expr&#39; and any / will be replaced by address of first match.
        # Search starts from current line and wraps around if needed.
        # If nothing found, return bad address to trigger error msg.
        if cmd_string.startswith(&#39;/&#39;) == True:
            closing_slash_position = cmd_string.find(&#39;/&#39;, 1)
            if closing_slash_position == -1:
                expr = cmd_string[1:]
                line_num = self.find_line(expr, self._current_line+1) or self.find_line(expr)
                if line_num != None:
                    cmd_string = cmd_string.replace(&#39;/&#39;+expr, str(line_num))
                else:
                    return -1, None, &#39;p&#39;, None
            else:
                expr = cmd_string[1:closing_slash_position]
                line_num = self.find_line(expr, self._current_line+1) or self.find_line(expr)
                if line_num != None:
                    cmd_string = cmd_string.replace(&#39;/&#39;+expr+&#39;/&#39;, str(line_num))
                else:
                    return -1, None, &#39;p&#39;, None

        # Numeric format can be a single line number, like {n}
        # or a range, like {n1},{n2} Addresses can have the familiar ed/vi
        # characters like . % $  There is also &gt; which equates to the range
        # of current_line to current_line+20 which is useful for paging.
        cmd_location = 0
        for ch in cmd_string:
            if ch not in &#39;0123456789$%,.&gt;&#39;:  # all valid address range chars
                break
            cmd_location += 1

        if cmd_location == 0:
            addr1 = None
            addr2 = None
        else:
            addr_range = cmd_string[0:cmd_location]
            if addr_range[0] == &#39;%&#39;:  # entire buffer
                addr_range = addr_range.replace(&#39;%&#39;, &#39;1,$&#39;)
            if addr_range[0] == &#39;&gt;&#39;:  # page forward
                stop_line = self._current_line + 22
                if stop_line &gt; len(self._buffer):
                    stop_line = len(self._buffer)
                addr_range = addr_range.replace(&#39;&gt;&#39;, &#39;.,{}&#39;.format(stop_line))

            addr_range = addr_range.replace(&#39;.&#39;, str(self._current_line))
            addr_range = addr_range.replace(&#39;$&#39;, str(len(self._buffer)))

            if &#39;,&#39; in addr_range:
                addr1 = int(addr_range.split(&#39;,&#39;)[0])
                addr2 = int(addr_range.split(&#39;,&#39;)[1])
            else:
                addr1 = int(addr_range)
                addr2 = None

        # Commands are single-character and mimic ed&#39;s commands. When
        # no command exists, the default action is to &#39;print&#39; the line.
        cmd = cmd_string[cmd_location:cmd_location+1]
        if cmd == &#39;&#39;:
            cmd = &#39;p&#39;

        # The single parameter that follows the command is multi-use.
        # In some cases it can be a destination address (move, transfer)
        # or a file path in others (edit, write).
        # The . and $ substitutions are valid here, but not %
        param = cmd_string[cmd_location+1:].strip()
        if param.isdigit() == True:
            param = int(param)
        elif param == &#39;.&#39;:
            param = self._current_line
        elif param == &#39;$&#39;:
            param = len(self._buffer)

        return addr1, addr2, cmd, param

    def begin(self):
        &#34;&#34;&#34;
        Use interactive commands to modify the text buffer.
        &#34;&#34;&#34;
        cmd_functions = {
            &#39;=&#39;: self.show_line_number,
            &#39;a&#39;: self.append,
            &#39;c&#39;: self.change,
            &#39;d&#39;: self.delete,
            &#39;e&#39;: self.edit,
            &#39;E&#39;: self.edit_unconditional,
            &#39;f&#39;: self.file,
            &#39;h&#39;: self.help,
            &#39;H&#39;: self.toggle_verbosity,
            &#39;i&#39;: self.insert,
            &#39;j&#39;: self.join,
            &#39;m&#39;: self.move,
            &#39;n&#39;: self.number,
            &#39;p&#39;: self.print,
            &#39;q&#39;: self.quit,
            &#39;Q&#39;: self.quit_unconditional,
            &#39;t&#39;: self.transfer,
            &#39;w&#39;: self.write
        }

        self._current_line = len(self._buffer)

        while True:
            cmd_string = input(self.cmd_prompt)
            addr1, addr2, cmd, param = self.parse(cmd_string)
            if cmd not in cmd_functions:
                stdout.write(&#39;Unrecognized cmd. Try h for help.\n&#39;)
            else:
                result = cmd_functions[cmd](start=addr1, stop=addr2, param=param)
                if result == False:
                    stdout.write(&#39;Bad address range.\n&#39;)

def atto(filename=None):
    editor = Atto(filename)
    editor.begin()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="atto.atto"><code class="name flex">
<span>def <span class="ident">atto</span></span>(<span>filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atto(filename=None):
    editor = Atto(filename)
    editor.begin()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atto.Atto"><code class="flex name class">
<span>class <span class="ident">Atto</span></span>
<span>(</span><span>filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A primitive line editor, painfully similar to the ed editor, but
with without the cool regex stuff.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Atto(TextBuffer):
    &#34;&#34;&#34;
    A primitive line editor, painfully similar to the ed editor, but
    with without the cool regex stuff.
    &#34;&#34;&#34;
    cmd_prompt = &#39;*&#39;
    text_prompt = &#39;&gt;&#39;

    def help(self, **kwargs):
        &#34;&#34;&#34;
        Display brief usage summary
        &#34;&#34;&#34;
        help_text = &#39;\n&#39;.join([
            &#39;Usage: {addr}cmd&#39;,
            &#39;&#39;,
            &#39;Line Addressing&#39;,
            &#39;------------------------------&#39;,
            &#39;{n}         single line&#39;,
            &#39;{n1},{n2}   range of lines&#39;,
            &#39;.           current line&#39;,
            &#39;$           last line&#39;,
            &#39;%           all lines 1,$&#39;,
            &#39;/regexp/    next matching line&#39;,
            &#39;&#39;,
            &#39;Command Summary&#39;,
            &#39;---------------------------------------&#39;,
            &#39;{n}a        Append new line(s) after&#39;,
            &#39;{n1},{n2}c  Change (replace) line(s)&#39;,
            &#39;{n1},{n2}d  Delete line(s)&#39;,
            &#39;e [path]    Edit new file&#39;,
            &#39;f [path]    View/change filename&#39;,
            &#39;{n}i        Insert new line(s) before&#39;,
            &#39;{n1},{n2}n  Print with numbered lines&#39;,
            &#39;{n1},{n2}p  Print&#39;,
            &#39;q           Quit&#39;,
            &#39;w [path]    Write (save) buffer to file&#39;
        ])
        stdout.write(help_text + &#39;\n&#39;)

    def _input_multiline(self):
        &#34;&#34;&#34;
        Yield user input as lines until a single . is encountered.
        Used by insert and append operations.
        &#34;&#34;&#34;
        stdout.write(&#39;Enter a single . to exit input mode.\n&#39;)
        while True:
            text = input(self.text_prompt)
            if text != &#39;.&#39;:
                yield text
            else:
                return

    def _prompt_filename(self, prompt=&#39;Filename&#39;):
        &#34;&#34;&#34;
        Ask for a filename offering the current one as a default value.
        &#34;&#34;&#34;
        if self.filename != None:
            filename = input(&#39;{:s} [{:s}]: &#39;.format(prompt, self.filename))
        else:
            filename = input(&#39;{:s}: &#39;.format(prompt))
        return filename

    def _is_valid_addr(self, start=None, stop=None, dest=None, zero_start_ok=False):
        &#34;&#34;&#34;
        Test if address parameters in range, non-overlapping, etc.
        &#34;&#34;&#34;
        valid_start = 0 if (zero_start_ok == True) else 1

        if start == None:
            return False
        if start &lt; valid_start or start &gt; len(self._buffer):
            return False

        if stop != None:
            if stop &lt; 1 or stop &gt; len(self._buffer):
                return False
            if stop &lt; start:
                return False

        if dest != None:
            if dest &lt; 0 or dest &gt; len(self._buffer):
                return False
            if dest &gt;= start and dest &lt;= stop:
                return False

        return True

    def append(self, **kwargs):
        &#34;&#34;&#34;
        Add new lines after the indicated line number.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        if self._is_valid_addr(start, zero_start_ok=True) == False:
            return False

        line_num = start
        for line in self._input_multiline():
            line_num += 1
            self.insert_line(line_num, line)
        self._current_line = line_num

    def change(self, **kwargs):
        &#34;&#34;&#34;
        Replace line(s) with new line(s).
        &#34;&#34;&#34;
        self.delete(**kwargs)
        self.insert(**kwargs)

    def delete(self, **kwargs):
        &#34;&#34;&#34;
        Remove a range of lines from the buffer.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or start
        if self._is_valid_addr(start, stop) == False:
            return False
        self.delete_range(start, stop)
        self._current_line = start

    def edit(self, **kwargs):
        &#34;&#34;&#34;
        Load a new file into the buffer.
        &#34;&#34;&#34;
        if self._is_dirty == True:
            stdout.write(&#39;Unsaved changes exist. Use uppercase E to override.\n&#39;)
        else:
            filename = kwargs.get(&#39;param&#39;) or self.filename or self._prompt_filename()
            if filename != None:
                self.purge()
                self.load(filename)
                self._is_dirty = False
                self._current_line = len(self._buffer)
                self.filename = filename

    def edit_unconditional(self, **kwargs):
        &#34;&#34;&#34;
        Load a new file into the buffer, disregarding unsaved changes.
        &#34;&#34;&#34;
        self._is_dirty = False
        self.edit(**kwargs)

    def file(self, **kwargs):
        &#34;&#34;&#34;
        Show current filename or replace if param is present
        &#34;&#34;&#34;
        new_name = kwargs.get(&#39;param&#39;)
        if new_name != &#39;&#39;:
            self.filename = new_name
        else:
            stdout.write((self.filename or &#39;(none)&#39;) + &#39;\n&#39;)

    def insert(self, **kwargs):
        &#34;&#34;&#34;
        Add new lines after the indicated line number.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        if self._is_valid_addr(start) == False:
            return False

        line_num = start
        for line in self._input_multiline():
            self.insert_line(line_num, line)
            line_num += 1
        self._current_line = line_num - 1

    def join(self, **kwargs):
        &#34;&#34;&#34;
        Combine lines.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or self._current_line
        if self._is_valid_addr(start, stop) == False:
            return False

        self._buffer[start-1:stop] = [&#39;&#39;.join(self._buffer[start-1:stop])]
        self._current_line = start
        self._is_dirty = True

    def move(self, **kwargs):
        &#34;&#34;&#34;
        Like transfer but remove the source range after the copy.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;)
        stop = kwargs.get(&#39;stop&#39;) or start
        dest = kwargs.get(&#39;param&#39;)
        if self._is_valid_addr(start, stop) == False:
            return False
        self.copy_range(start, stop, dest)
        offset = stop - start + 1 if (dest &lt; start) else 0
        self.delete_range(start+offset, stop+offset)
        self._current_line = dest - 1 + stop - start

    def number(self, **kwargs):
        &#34;&#34;&#34;
        Print lines prefixed with line numbers.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or start
        if self._is_valid_addr(start, stop) == False:
            return False

        if stop &lt; 10:
            line_num_field = &#39;{:&gt;1d}&#39;
        elif stop &lt; 100:
            line_num_field = &#39;{:&gt;2d}&#39;
        elif stop &lt; 1000:
            line_num_field = &#39;{:&gt;3d}&#39;
        else:
            line_num_field = &#39;{:&gt;4d}&#39;

        line_num = start
        while line_num &lt;= stop:
            stdout.write(line_num_field.format(line_num) + &#39; &#39;)
            stdout.write(self.get_line(line_num) + &#39;\n&#39;)
            line_num += 1
        self._current_line = stop

    def print(self, **kwargs):
        &#34;&#34;&#34;
        Display a range of buffer lines, possibly truncated to fit.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;) or self._current_line
        stop = kwargs.get(&#39;stop&#39;) or start
        line_length = kwargs.get(&#39;line_length&#39;)
        if self._is_valid_addr(start, stop) == False:
            return False

        line_num = start
        while line_num &lt;= stop:
            if line_length == None:
                stdout.write(self.get_line(line_num) + &#39;\n&#39;)
            else:
                stdout.write(self.get_line(line_num)[:line_length] + &#39;\n&#39;)
            line_num += 1
        self._current_line = stop

    def quit(self, **kwargs):
        if self._is_dirty == False or kwargs.get(&#39;param&#39;) == &#39;!&#39;:
            self.quit_unconditional()
        else:
            stdout.write(&#39;Unsaved changes exist. Use uppercase Q to override.\n&#39;)

    def quit_unconditional(self, **kwargs):
        del self._buffer
        exit(0)

    def show_line_number(self, **kwargs):
        line_num = kwargs.get(&#39;start&#39;) or self._current_line
        stdout.write(str(line_num) + &#39;\n&#39;)

    def toggle_verbosity(self, **kwargs):
        self.verbose = not self.verbose
        state = &#39;on&#39; if self.verbose else &#39;off&#39;
        stdout.write(&#39;Verbose messages: {}\n&#39;.format(state))

    def transfer(self, **kwargs):
        &#34;&#34;&#34;
        Copy lines start..stop to the line after dest.
        &#34;&#34;&#34;
        start = kwargs.get(&#39;start&#39;)
        stop = kwargs.get(&#39;stop&#39;) or start
        dest = kwargs.get(&#39;param&#39;)
        if self._is_valid_addr(start, stop) == False:
            return False
        self.copy_range(start, stop, dest)
        self._current_line = dest + stop - start + 1

    def write(self, **kwargs):
        &#34;&#34;&#34;
        Save the buffer to a file.
        &#34;&#34;&#34;
        filename = kwargs.get(&#39;param&#39;) or self.filename or self._prompt_filename()
        if (filename):
            result = self.save(filename)
            if (result == False):
                stdout.write(&#39;Write failed!\n&#39;)

    def parse(self, cmd_string):
        &#34;&#34;&#34;
        Split a command string into address range, command, and parameter.
        &#34;&#34;&#34;
        if (cmd_string == None or cmd_string == &#39;&#39;):
            return None, None, None, None

        # RegEx address format can be &#39;/expr&#39; or &#39;/expr/&#39;
        # &#39;expr&#39; and any / will be replaced by address of first match.
        # Search starts from current line and wraps around if needed.
        # If nothing found, return bad address to trigger error msg.
        if cmd_string.startswith(&#39;/&#39;) == True:
            closing_slash_position = cmd_string.find(&#39;/&#39;, 1)
            if closing_slash_position == -1:
                expr = cmd_string[1:]
                line_num = self.find_line(expr, self._current_line+1) or self.find_line(expr)
                if line_num != None:
                    cmd_string = cmd_string.replace(&#39;/&#39;+expr, str(line_num))
                else:
                    return -1, None, &#39;p&#39;, None
            else:
                expr = cmd_string[1:closing_slash_position]
                line_num = self.find_line(expr, self._current_line+1) or self.find_line(expr)
                if line_num != None:
                    cmd_string = cmd_string.replace(&#39;/&#39;+expr+&#39;/&#39;, str(line_num))
                else:
                    return -1, None, &#39;p&#39;, None

        # Numeric format can be a single line number, like {n}
        # or a range, like {n1},{n2} Addresses can have the familiar ed/vi
        # characters like . % $  There is also &gt; which equates to the range
        # of current_line to current_line+20 which is useful for paging.
        cmd_location = 0
        for ch in cmd_string:
            if ch not in &#39;0123456789$%,.&gt;&#39;:  # all valid address range chars
                break
            cmd_location += 1

        if cmd_location == 0:
            addr1 = None
            addr2 = None
        else:
            addr_range = cmd_string[0:cmd_location]
            if addr_range[0] == &#39;%&#39;:  # entire buffer
                addr_range = addr_range.replace(&#39;%&#39;, &#39;1,$&#39;)
            if addr_range[0] == &#39;&gt;&#39;:  # page forward
                stop_line = self._current_line + 22
                if stop_line &gt; len(self._buffer):
                    stop_line = len(self._buffer)
                addr_range = addr_range.replace(&#39;&gt;&#39;, &#39;.,{}&#39;.format(stop_line))

            addr_range = addr_range.replace(&#39;.&#39;, str(self._current_line))
            addr_range = addr_range.replace(&#39;$&#39;, str(len(self._buffer)))

            if &#39;,&#39; in addr_range:
                addr1 = int(addr_range.split(&#39;,&#39;)[0])
                addr2 = int(addr_range.split(&#39;,&#39;)[1])
            else:
                addr1 = int(addr_range)
                addr2 = None

        # Commands are single-character and mimic ed&#39;s commands. When
        # no command exists, the default action is to &#39;print&#39; the line.
        cmd = cmd_string[cmd_location:cmd_location+1]
        if cmd == &#39;&#39;:
            cmd = &#39;p&#39;

        # The single parameter that follows the command is multi-use.
        # In some cases it can be a destination address (move, transfer)
        # or a file path in others (edit, write).
        # The . and $ substitutions are valid here, but not %
        param = cmd_string[cmd_location+1:].strip()
        if param.isdigit() == True:
            param = int(param)
        elif param == &#39;.&#39;:
            param = self._current_line
        elif param == &#39;$&#39;:
            param = len(self._buffer)

        return addr1, addr2, cmd, param

    def begin(self):
        &#34;&#34;&#34;
        Use interactive commands to modify the text buffer.
        &#34;&#34;&#34;
        cmd_functions = {
            &#39;=&#39;: self.show_line_number,
            &#39;a&#39;: self.append,
            &#39;c&#39;: self.change,
            &#39;d&#39;: self.delete,
            &#39;e&#39;: self.edit,
            &#39;E&#39;: self.edit_unconditional,
            &#39;f&#39;: self.file,
            &#39;h&#39;: self.help,
            &#39;H&#39;: self.toggle_verbosity,
            &#39;i&#39;: self.insert,
            &#39;j&#39;: self.join,
            &#39;m&#39;: self.move,
            &#39;n&#39;: self.number,
            &#39;p&#39;: self.print,
            &#39;q&#39;: self.quit,
            &#39;Q&#39;: self.quit_unconditional,
            &#39;t&#39;: self.transfer,
            &#39;w&#39;: self.write
        }

        self._current_line = len(self._buffer)

        while True:
            cmd_string = input(self.cmd_prompt)
            addr1, addr2, cmd, param = self.parse(cmd_string)
            if cmd not in cmd_functions:
                stdout.write(&#39;Unrecognized cmd. Try h for help.\n&#39;)
            else:
                result = cmd_functions[cmd](start=addr1, stop=addr2, param=param)
                if result == False:
                    stdout.write(&#39;Bad address range.\n&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>text_buffer.TextBuffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="atto.Atto.cmd_prompt"><code class="name">var <span class="ident">cmd_prompt</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="atto.Atto.text_prompt"><code class="name">var <span class="ident">text_prompt</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atto.Atto.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add new lines after the indicated line number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, **kwargs):
    &#34;&#34;&#34;
    Add new lines after the indicated line number.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;) or self._current_line
    if self._is_valid_addr(start, zero_start_ok=True) == False:
        return False

    line_num = start
    for line in self._input_multiline():
        line_num += 1
        self.insert_line(line_num, line)
    self._current_line = line_num</code></pre>
</details>
</dd>
<dt id="atto.Atto.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Use interactive commands to modify the text buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin(self):
    &#34;&#34;&#34;
    Use interactive commands to modify the text buffer.
    &#34;&#34;&#34;
    cmd_functions = {
        &#39;=&#39;: self.show_line_number,
        &#39;a&#39;: self.append,
        &#39;c&#39;: self.change,
        &#39;d&#39;: self.delete,
        &#39;e&#39;: self.edit,
        &#39;E&#39;: self.edit_unconditional,
        &#39;f&#39;: self.file,
        &#39;h&#39;: self.help,
        &#39;H&#39;: self.toggle_verbosity,
        &#39;i&#39;: self.insert,
        &#39;j&#39;: self.join,
        &#39;m&#39;: self.move,
        &#39;n&#39;: self.number,
        &#39;p&#39;: self.print,
        &#39;q&#39;: self.quit,
        &#39;Q&#39;: self.quit_unconditional,
        &#39;t&#39;: self.transfer,
        &#39;w&#39;: self.write
    }

    self._current_line = len(self._buffer)

    while True:
        cmd_string = input(self.cmd_prompt)
        addr1, addr2, cmd, param = self.parse(cmd_string)
        if cmd not in cmd_functions:
            stdout.write(&#39;Unrecognized cmd. Try h for help.\n&#39;)
        else:
            result = cmd_functions[cmd](start=addr1, stop=addr2, param=param)
            if result == False:
                stdout.write(&#39;Bad address range.\n&#39;)</code></pre>
</details>
</dd>
<dt id="atto.Atto.change"><code class="name flex">
<span>def <span class="ident">change</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace line(s) with new line(s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change(self, **kwargs):
    &#34;&#34;&#34;
    Replace line(s) with new line(s).
    &#34;&#34;&#34;
    self.delete(**kwargs)
    self.insert(**kwargs)</code></pre>
</details>
</dd>
<dt id="atto.Atto.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a range of lines from the buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, **kwargs):
    &#34;&#34;&#34;
    Remove a range of lines from the buffer.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;) or self._current_line
    stop = kwargs.get(&#39;stop&#39;) or start
    if self._is_valid_addr(start, stop) == False:
        return False
    self.delete_range(start, stop)
    self._current_line = start</code></pre>
</details>
</dd>
<dt id="atto.Atto.edit"><code class="name flex">
<span>def <span class="ident">edit</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a new file into the buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit(self, **kwargs):
    &#34;&#34;&#34;
    Load a new file into the buffer.
    &#34;&#34;&#34;
    if self._is_dirty == True:
        stdout.write(&#39;Unsaved changes exist. Use uppercase E to override.\n&#39;)
    else:
        filename = kwargs.get(&#39;param&#39;) or self.filename or self._prompt_filename()
        if filename != None:
            self.purge()
            self.load(filename)
            self._is_dirty = False
            self._current_line = len(self._buffer)
            self.filename = filename</code></pre>
</details>
</dd>
<dt id="atto.Atto.edit_unconditional"><code class="name flex">
<span>def <span class="ident">edit_unconditional</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a new file into the buffer, disregarding unsaved changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_unconditional(self, **kwargs):
    &#34;&#34;&#34;
    Load a new file into the buffer, disregarding unsaved changes.
    &#34;&#34;&#34;
    self._is_dirty = False
    self.edit(**kwargs)</code></pre>
</details>
</dd>
<dt id="atto.Atto.file"><code class="name flex">
<span>def <span class="ident">file</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Show current filename or replace if param is present</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file(self, **kwargs):
    &#34;&#34;&#34;
    Show current filename or replace if param is present
    &#34;&#34;&#34;
    new_name = kwargs.get(&#39;param&#39;)
    if new_name != &#39;&#39;:
        self.filename = new_name
    else:
        stdout.write((self.filename or &#39;(none)&#39;) + &#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="atto.Atto.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Display brief usage summary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def help(self, **kwargs):
    &#34;&#34;&#34;
    Display brief usage summary
    &#34;&#34;&#34;
    help_text = &#39;\n&#39;.join([
        &#39;Usage: {addr}cmd&#39;,
        &#39;&#39;,
        &#39;Line Addressing&#39;,
        &#39;------------------------------&#39;,
        &#39;{n}         single line&#39;,
        &#39;{n1},{n2}   range of lines&#39;,
        &#39;.           current line&#39;,
        &#39;$           last line&#39;,
        &#39;%           all lines 1,$&#39;,
        &#39;/regexp/    next matching line&#39;,
        &#39;&#39;,
        &#39;Command Summary&#39;,
        &#39;---------------------------------------&#39;,
        &#39;{n}a        Append new line(s) after&#39;,
        &#39;{n1},{n2}c  Change (replace) line(s)&#39;,
        &#39;{n1},{n2}d  Delete line(s)&#39;,
        &#39;e [path]    Edit new file&#39;,
        &#39;f [path]    View/change filename&#39;,
        &#39;{n}i        Insert new line(s) before&#39;,
        &#39;{n1},{n2}n  Print with numbered lines&#39;,
        &#39;{n1},{n2}p  Print&#39;,
        &#39;q           Quit&#39;,
        &#39;w [path]    Write (save) buffer to file&#39;
    ])
    stdout.write(help_text + &#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="atto.Atto.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add new lines after the indicated line number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, **kwargs):
    &#34;&#34;&#34;
    Add new lines after the indicated line number.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;) or self._current_line
    if self._is_valid_addr(start) == False:
        return False

    line_num = start
    for line in self._input_multiline():
        self.insert_line(line_num, line)
        line_num += 1
    self._current_line = line_num - 1</code></pre>
</details>
</dd>
<dt id="atto.Atto.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, **kwargs):
    &#34;&#34;&#34;
    Combine lines.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;) or self._current_line
    stop = kwargs.get(&#39;stop&#39;) or self._current_line
    if self._is_valid_addr(start, stop) == False:
        return False

    self._buffer[start-1:stop] = [&#39;&#39;.join(self._buffer[start-1:stop])]
    self._current_line = start
    self._is_dirty = True</code></pre>
</details>
</dd>
<dt id="atto.Atto.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like transfer but remove the source range after the copy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, **kwargs):
    &#34;&#34;&#34;
    Like transfer but remove the source range after the copy.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;)
    stop = kwargs.get(&#39;stop&#39;) or start
    dest = kwargs.get(&#39;param&#39;)
    if self._is_valid_addr(start, stop) == False:
        return False
    self.copy_range(start, stop, dest)
    offset = stop - start + 1 if (dest &lt; start) else 0
    self.delete_range(start+offset, stop+offset)
    self._current_line = dest - 1 + stop - start</code></pre>
</details>
</dd>
<dt id="atto.Atto.number"><code class="name flex">
<span>def <span class="ident">number</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Print lines prefixed with line numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number(self, **kwargs):
    &#34;&#34;&#34;
    Print lines prefixed with line numbers.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;) or self._current_line
    stop = kwargs.get(&#39;stop&#39;) or start
    if self._is_valid_addr(start, stop) == False:
        return False

    if stop &lt; 10:
        line_num_field = &#39;{:&gt;1d}&#39;
    elif stop &lt; 100:
        line_num_field = &#39;{:&gt;2d}&#39;
    elif stop &lt; 1000:
        line_num_field = &#39;{:&gt;3d}&#39;
    else:
        line_num_field = &#39;{:&gt;4d}&#39;

    line_num = start
    while line_num &lt;= stop:
        stdout.write(line_num_field.format(line_num) + &#39; &#39;)
        stdout.write(self.get_line(line_num) + &#39;\n&#39;)
        line_num += 1
    self._current_line = stop</code></pre>
</details>
</dd>
<dt id="atto.Atto.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, cmd_string)</span>
</code></dt>
<dd>
<div class="desc"><p>Split a command string into address range, command, and parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, cmd_string):
    &#34;&#34;&#34;
    Split a command string into address range, command, and parameter.
    &#34;&#34;&#34;
    if (cmd_string == None or cmd_string == &#39;&#39;):
        return None, None, None, None

    # RegEx address format can be &#39;/expr&#39; or &#39;/expr/&#39;
    # &#39;expr&#39; and any / will be replaced by address of first match.
    # Search starts from current line and wraps around if needed.
    # If nothing found, return bad address to trigger error msg.
    if cmd_string.startswith(&#39;/&#39;) == True:
        closing_slash_position = cmd_string.find(&#39;/&#39;, 1)
        if closing_slash_position == -1:
            expr = cmd_string[1:]
            line_num = self.find_line(expr, self._current_line+1) or self.find_line(expr)
            if line_num != None:
                cmd_string = cmd_string.replace(&#39;/&#39;+expr, str(line_num))
            else:
                return -1, None, &#39;p&#39;, None
        else:
            expr = cmd_string[1:closing_slash_position]
            line_num = self.find_line(expr, self._current_line+1) or self.find_line(expr)
            if line_num != None:
                cmd_string = cmd_string.replace(&#39;/&#39;+expr+&#39;/&#39;, str(line_num))
            else:
                return -1, None, &#39;p&#39;, None

    # Numeric format can be a single line number, like {n}
    # or a range, like {n1},{n2} Addresses can have the familiar ed/vi
    # characters like . % $  There is also &gt; which equates to the range
    # of current_line to current_line+20 which is useful for paging.
    cmd_location = 0
    for ch in cmd_string:
        if ch not in &#39;0123456789$%,.&gt;&#39;:  # all valid address range chars
            break
        cmd_location += 1

    if cmd_location == 0:
        addr1 = None
        addr2 = None
    else:
        addr_range = cmd_string[0:cmd_location]
        if addr_range[0] == &#39;%&#39;:  # entire buffer
            addr_range = addr_range.replace(&#39;%&#39;, &#39;1,$&#39;)
        if addr_range[0] == &#39;&gt;&#39;:  # page forward
            stop_line = self._current_line + 22
            if stop_line &gt; len(self._buffer):
                stop_line = len(self._buffer)
            addr_range = addr_range.replace(&#39;&gt;&#39;, &#39;.,{}&#39;.format(stop_line))

        addr_range = addr_range.replace(&#39;.&#39;, str(self._current_line))
        addr_range = addr_range.replace(&#39;$&#39;, str(len(self._buffer)))

        if &#39;,&#39; in addr_range:
            addr1 = int(addr_range.split(&#39;,&#39;)[0])
            addr2 = int(addr_range.split(&#39;,&#39;)[1])
        else:
            addr1 = int(addr_range)
            addr2 = None

    # Commands are single-character and mimic ed&#39;s commands. When
    # no command exists, the default action is to &#39;print&#39; the line.
    cmd = cmd_string[cmd_location:cmd_location+1]
    if cmd == &#39;&#39;:
        cmd = &#39;p&#39;

    # The single parameter that follows the command is multi-use.
    # In some cases it can be a destination address (move, transfer)
    # or a file path in others (edit, write).
    # The . and $ substitutions are valid here, but not %
    param = cmd_string[cmd_location+1:].strip()
    if param.isdigit() == True:
        param = int(param)
    elif param == &#39;.&#39;:
        param = self._current_line
    elif param == &#39;$&#39;:
        param = len(self._buffer)

    return addr1, addr2, cmd, param</code></pre>
</details>
</dd>
<dt id="atto.Atto.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a range of buffer lines, possibly truncated to fit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, **kwargs):
    &#34;&#34;&#34;
    Display a range of buffer lines, possibly truncated to fit.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;) or self._current_line
    stop = kwargs.get(&#39;stop&#39;) or start
    line_length = kwargs.get(&#39;line_length&#39;)
    if self._is_valid_addr(start, stop) == False:
        return False

    line_num = start
    while line_num &lt;= stop:
        if line_length == None:
            stdout.write(self.get_line(line_num) + &#39;\n&#39;)
        else:
            stdout.write(self.get_line(line_num)[:line_length] + &#39;\n&#39;)
        line_num += 1
    self._current_line = stop</code></pre>
</details>
</dd>
<dt id="atto.Atto.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self, **kwargs):
    if self._is_dirty == False or kwargs.get(&#39;param&#39;) == &#39;!&#39;:
        self.quit_unconditional()
    else:
        stdout.write(&#39;Unsaved changes exist. Use uppercase Q to override.\n&#39;)</code></pre>
</details>
</dd>
<dt id="atto.Atto.quit_unconditional"><code class="name flex">
<span>def <span class="ident">quit_unconditional</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit_unconditional(self, **kwargs):
    del self._buffer
    exit(0)</code></pre>
</details>
</dd>
<dt id="atto.Atto.show_line_number"><code class="name flex">
<span>def <span class="ident">show_line_number</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_line_number(self, **kwargs):
    line_num = kwargs.get(&#39;start&#39;) or self._current_line
    stdout.write(str(line_num) + &#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="atto.Atto.toggle_verbosity"><code class="name flex">
<span>def <span class="ident">toggle_verbosity</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_verbosity(self, **kwargs):
    self.verbose = not self.verbose
    state = &#39;on&#39; if self.verbose else &#39;off&#39;
    stdout.write(&#39;Verbose messages: {}\n&#39;.format(state))</code></pre>
</details>
</dd>
<dt id="atto.Atto.transfer"><code class="name flex">
<span>def <span class="ident">transfer</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy lines start..stop to the line after dest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer(self, **kwargs):
    &#34;&#34;&#34;
    Copy lines start..stop to the line after dest.
    &#34;&#34;&#34;
    start = kwargs.get(&#39;start&#39;)
    stop = kwargs.get(&#39;stop&#39;) or start
    dest = kwargs.get(&#39;param&#39;)
    if self._is_valid_addr(start, stop) == False:
        return False
    self.copy_range(start, stop, dest)
    self._current_line = dest + stop - start + 1</code></pre>
</details>
</dd>
<dt id="atto.Atto.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the buffer to a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, **kwargs):
    &#34;&#34;&#34;
    Save the buffer to a file.
    &#34;&#34;&#34;
    filename = kwargs.get(&#39;param&#39;) or self.filename or self._prompt_filename()
    if (filename):
        result = self.save(filename)
        if (result == False):
            stdout.write(&#39;Write failed!\n&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="atto.atto" href="#atto.atto">atto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atto.Atto" href="#atto.Atto">Atto</a></code></h4>
<ul class="two-column">
<li><code><a title="atto.Atto.append" href="#atto.Atto.append">append</a></code></li>
<li><code><a title="atto.Atto.begin" href="#atto.Atto.begin">begin</a></code></li>
<li><code><a title="atto.Atto.change" href="#atto.Atto.change">change</a></code></li>
<li><code><a title="atto.Atto.cmd_prompt" href="#atto.Atto.cmd_prompt">cmd_prompt</a></code></li>
<li><code><a title="atto.Atto.delete" href="#atto.Atto.delete">delete</a></code></li>
<li><code><a title="atto.Atto.edit" href="#atto.Atto.edit">edit</a></code></li>
<li><code><a title="atto.Atto.edit_unconditional" href="#atto.Atto.edit_unconditional">edit_unconditional</a></code></li>
<li><code><a title="atto.Atto.file" href="#atto.Atto.file">file</a></code></li>
<li><code><a title="atto.Atto.help" href="#atto.Atto.help">help</a></code></li>
<li><code><a title="atto.Atto.insert" href="#atto.Atto.insert">insert</a></code></li>
<li><code><a title="atto.Atto.join" href="#atto.Atto.join">join</a></code></li>
<li><code><a title="atto.Atto.move" href="#atto.Atto.move">move</a></code></li>
<li><code><a title="atto.Atto.number" href="#atto.Atto.number">number</a></code></li>
<li><code><a title="atto.Atto.parse" href="#atto.Atto.parse">parse</a></code></li>
<li><code><a title="atto.Atto.print" href="#atto.Atto.print">print</a></code></li>
<li><code><a title="atto.Atto.quit" href="#atto.Atto.quit">quit</a></code></li>
<li><code><a title="atto.Atto.quit_unconditional" href="#atto.Atto.quit_unconditional">quit_unconditional</a></code></li>
<li><code><a title="atto.Atto.show_line_number" href="#atto.Atto.show_line_number">show_line_number</a></code></li>
<li><code><a title="atto.Atto.text_prompt" href="#atto.Atto.text_prompt">text_prompt</a></code></li>
<li><code><a title="atto.Atto.toggle_verbosity" href="#atto.Atto.toggle_verbosity">toggle_verbosity</a></code></li>
<li><code><a title="atto.Atto.transfer" href="#atto.Atto.transfer">transfer</a></code></li>
<li><code><a title="atto.Atto.write" href="#atto.Atto.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
